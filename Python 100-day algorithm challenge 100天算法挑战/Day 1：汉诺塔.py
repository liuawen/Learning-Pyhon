def hanoi(height, left='left', right='right', middle='middle'):
    if height:
        hanoi(height - 1, left, middle, right)
        print(left, '=>', right)
        hanoi(height - 1, middle, right, left)
        
hanoi(3)
def hanoi1(n, a, b, c):
    if n == 1:
        print(a, '-->', c)
    else:
        hanoi(n - 1, a, c, b)
        print(a, '-->', c)
        hanoi(n - 1, b, a, c)
# 调用
hanoi1(3, 'A', 'B', 'C')
def move(n,a,b,c):
    #n为圆盘数，a代表初始位圆柱，b代表过渡位圆柱，c代表目标位圆柱
	if n==1:
		print(a,'-->',c)
	else:
		move(n-1,a,c,b)   #将初始位的n-1个圆盘移动到过渡位，此时初始位为a，上一级函数的过渡位b即为本级的目标位，上级的目标位c为本级的过渡位
		print(a,'-->',c)
 
		move(n-1,b,a,c)   #将过渡位的n-1个圆盘移动到目标位，此时初始位为b，上一级函数的目标位c即为本级的目标位，上级的初始位a为本级的过渡位
move(3, 'A', 'B', 'C')
'''
我们先学习一个简单的算法：汉诺塔。
当然，如果你之前不了解它，会觉得它很费解。
它有一个很有意思的递归解决方案。
汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，
源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，
在一根柱子上从下往上按照大小顺序摞着N片黄金圆盘。
大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。
并且规定，任何时候，在小圆盘上都不能放大圆盘，
且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？
试想一下，如果我们要将最大的圆盘移动到最右边的柱子上。
我们需要把除此圆盘的其他圆盘先移动到中间的柱子上。
因此这个问题就变成了如何将 N-1 个圆盘移动到中间的柱子上。
很容易我们就想到了递归的方法。

将 N 个圆盘从左边柱子移动到右边柱子：
[递归的]将 N-1 个圆盘从左边柱子移动到中间柱子。
将最大的圆盘从左边柱子移动到右边柱子。
[递归的]将 N-1 个圆盘从中间柱子移动到右边柱子。

'''
